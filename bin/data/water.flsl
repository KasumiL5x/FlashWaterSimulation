use namespace flare;
//use namespace flare.transforms;
//use namespace flare.filters;
use namespace flare.blendMode;

samplerCube CubeTex;
sampler2D ReflectionTex;
param float3 BaseColor = float3(1.0, 0.0, 0.0);
param float Ambient = 0.2;

// -*- Foam properties -*-
param float FoamMinHeight = 3.0;
param float FoamMaxHeight = 5.1;
param float3 FoamColor = float3(0.2);

// -*- Sunlight properties -*-
param float SunStrength = 5.0;
param float SunShine = 30.0;
param float3 SunColor = float3(1.2, 0.4, 0.1);
param float SunPow = 0.45454545454545454545454545454545;

// -*- wave color properties -*-
param float WaveColorMod = 0.60;
param float WaveColorPow = 4.0;

// -*- Specular properties -*-
param float SpecularPow = 1.0;
param float SpecularMod = 0.66;

interpolated float3 interp_pos;
interpolated float4 projected_pos;
interpolated float3 interp_nrm;

param float3 L = normalize(float3(0.4, 0.5, 0.4));

float4 vertexShader()
{
	float4 pos = position.xyzw;
	pos.y += color0.x;
	interp_pos = pos.xyz;
	pos *= worldViewProj;
	projected_pos = pos;
	
	float2 N_XZ = float2(color0.b, color0.a);
	interp_nrm = normalize(float3(color0.b, sqrt(1.0 - dot(N_XZ, N_XZ)), color0.a));
	
	return pos;
}

float4 fragmentShader()
{
	// Normal from VS.
	float3 N = interp_nrm;
	
	// Specular highlights (from some paper I found online).
	float3 vref = normalize(reflect(L, N)).xyz;
	float spec_tmp = max(0.0, dot(L, vref));
	spec_tmp = pow(spec_tmp, SpecularPow);
	float3 specularColor = float3(spec_tmp) * SpecularMod;
	
	// Final output color starting with ambient, base color, and specularity.
	float4 color = float4((Ambient * BaseColor) + specularColor, 0.0);
	
	// View vector.
	float3 V = normalize(interp_pos - camPos);
	// Reflection vector.
	float3 RV = normalize(reflect(V, N));
	// Cubemap reflection.
	float4 cube_reflect = samplerCube(CubeTex, RV);
	// Sunlight equation.
	float3 Sunlight = pow(SunStrength * pow(max(0.0, dot(RV, L)), SunShine) * SunColor, SunPow);
	// Mix with cubemap reflection and sunlight.
	color = mix(color, float4(cube_reflect.xyz + Sunlight, 0.0), 1.0);
	
	// Screen-space UV for reflections.
	float2 proj_uv = projected_pos.xy / projected_pos.w * const(0.5, -0.5) + 0.5;
	// Reflection of the scene (fudge the value a little to get some nice wavy sampling).
	float4 reflection_color = sampler2D(ReflectionTex, proj_uv + N.xz * 0.2);
	// Mix in the scene reflection.
	color = mix(color, float4(reflection_color.xyz, 0.0), 1.0 - reflection_color.a);

	// Simple lighting.
	float dp = max(dot(L, N), 0.0);
	
	// Mix in the base color of the water.
	color = mix(color, float4(BaseColor, 1.0), dp);

	// Color of wave based on height.
	float3 wave_color = min(BaseColor * WaveColorMod, pow(iColor0.rrr, WaveColorPow));
	// Mix in the wave color.
	color = mix(color, float4(wave_color, 1.0), dp);
	
	// Foam based on height.
	float3 foam = FoamColor * max(0.0, (iColor0.r - FoamMinHeight) / (FoamMaxHeight - FoamMinHeight));
	// Mix in the foam color.
	color = mix(color, float4(foam, 1.0), dp);
	
	return float4(color.xyz, color.a);
}

technique main
{
	output vertex = vertexShader();
	output fragment = fragmentShader();
	output sourceFactor = "one";
	output destFactor = "oneMinusSourceAlpha";
}
